/**
 * The buildscript block lets us tell Gradle about our dependency on ml-gradle and where to find its dependencies.
 */
buildscript {
  repositories {
    mavenCentral()
    maven {url "http://developer.marklogic.com/maven2/"}
    maven {url "http://rjrudin.github.io/marklogic-java/releases"}
  }
  
  dependencies {
    classpath "com.marklogic:ml-gradle:0.9.5"
  }
}

/*
 * This is a typical set of plugins for a Java project - support for Eclipse project files, the default Java 
 * support provided by Gradle, and the ml-gradle plugin.
 */
apply plugin: 'ml-gradle'



//
// To use ml-gradle, you only need what is above this line. Everything below this line is optional and is intended to
// show different features provided by ml-gradle.
//


/*
 * This is an example of applying a non-version controlled Gradle file that a user may wish to create to override 
 * properties defined in gradle.properties. Gradle does not provide an out-of-the-box mechanism for doing this, but the
 * below technique will do the job. The local.gradle file can define an "ext" block to override properties, as well as
 * including any other valid Gradle build scripting. 
 */
try {
  apply from: "local.gradle"
  println "Applied local.gradle file"
} catch (Exception e) {
  println "Couldn't find local.gradle; you can create this gitignore'd file to override properties if necessary"
}


/*
 * A typical Java team that uses Eclipse for development will apply both the eclipse and java plugins. See the Gradle
 * docs for these plugins to see everything that they provide.
 */ 
apply plugin: 'eclipse'
apply plugin: 'java'


/*
 * This lists the repositories for finding project dependencies (which differ from buildscript dependencies - buildscript
 * dependencies are not included in project artifacts that are built). These repositories are needed to satisfy the
 * dependencies expressed below. 
 */
repositories {
  mavenCentral()
  maven {url "http://developer.marklogic.com/maven2/"}
  maven {url "http://rjrudin.github.io/marklogic-java/releases"}
}


/*
 * This expresses dependencies on the ml-java and ml-junit libraries. The former is typically used for application 
 * code, and the latter supports writing JUnit-based tests. 
 */
dependencies {
  compile "com.marklogic:ml-java:0.9.5"
  testCompile "com.marklogic:ml-junit:0.9.5"
  
  // Located at https://github.com/rjrudin/marklogic-java/tree/gh-pages/releases/com/marklogic/corb
  runtime "com.marklogic:corb:1.0"
}


/*
 * For tests that reference test files in the test source tree, we need to tell Gradle to copy these to src/test/resources
 * so that they can be found when running "gradle test".
 */
sourceSets.test.resources.srcDir 'src/test/java'


/*
 * ml-gradle supports building a database package file by merging one or more partial database package files together. 
 * ml-gradle starts with a database package file with default settings and then merges in each of the package files
 * defined below to produce the package file that is used for creating a content database. See MergeDatabasePackagesTask
 * for more information.
 */
mlMergeDatabasePackages.mergePackageFilePaths = ["src/main/xqy/packages/content-database1.xml", "src/main/xqy/packages/content-database2.xml"]

/* 
 * ml-gradle supports building an HTTP server package file by merging one or more partial HTTP server package files together.
 * ml-gradle starts with an HTTP server package file with default settings and then merges in each of the packages files
 * defined below to produce a package file that is used for updating a REST API server. Note that this is for updating
 * the REST API server - the REST API in ML7 does not support much customization when creating a new REST API server.
 * So to utilize this merged HTTP server package file, you will need to invoke mlUpdateHttpServers. See
 * MergeHttpServerPackagesTask for more information.
 */
mlMergeHttpServerPackages.mergePackageFilePaths = ["src/main/xqy/packages/http-server.xml"]


/*
 * This is an example of both a custom Gradle task and an easy way of invoking Corb. This depends on "classes" to ensure 
 * that the Corb dependency is retrievied and on "mlLoadModules" to ensure that the Corb uris/transform modules are
 * loaded. 
 */
task corb(dependsOn: ['classes', 'mlLoadModules'], type: JavaExec) {
  main = 'com.marklogic.developer.corb.Manager'
  classpath = sourceSets.main.runtimeClasspath
  args = [mlAppConfig.xccUrl, '""', 'transform.xqy', '4', 'uris.xqy', '/ext/corb/', 'sample-project-modules', 'false']
}
